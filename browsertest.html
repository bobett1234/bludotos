<html>
<head>
<style>
#url {
    position: absolute;
    top: -10px;
    left: 25%;
    width: 50%;
    padding: 2px;
    background: #FFF;
    border: 3px solid #CCC;
    border-top-width: 10px;
    border-radius: 3px;
    box-shadow: 0 0 4px rgba(0,0,0,0.6);
    font-size: 110%;
    color: #555;
    z-index: 999;
}

#rend {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    /* height: 75%; */
    height: 100%;
    border: none;
    overflow: auto;
}

#insp {
    display: none;
    position: absolute;
    top: 75%;
    left: 0;
    width: 100%;
    height: 25%;
    background: #EEE;
    border-top: 2px solid #555;
    overflow: auto;
}

#throbber {
    display: none;
    position: absolute;
    top: 75%;
    right: 0;
    background: #000;
    padding: 1px 5px;
    color: #FFF;
    z-index: 999;
}
</style>
<script>
/** Copyright 2011 dvlpt.com */

(function(lib) {
	lib = {
		jsonp : function jsonp(u,cb,cbid){var a=jsonp._c=(jsonp._c||0)+1,b=cbid||'picojsonpcb'+a,c=document,d=c.body,s=c.createElement('script');window[b]=function(){this[b]=null;d.removeChild(s);cb.apply(cb,arguments);cb=c=d=s=null;};s.src=u.replace('{callback}',b);d.appendChild(s);},
		isArray : function(a){return Object.prototype.toString.call(a)==='[object Array]';},
		create : function(p,parent){var el=document.createElement(p.type || 'div'),i,frag;parent=parent||p.parent;if(p.attrs){lib.attrs(el,p.attrs);}if(p.props){lib.extend(el,p.props);}if(p.css){el.style.cssText=p.css;}if(p.children){frag=document.createDocumentFragment();lib.each(p.children,function(b){lib.create(b,frag);});el.appendChild(frag);frag=null;}if(p.insertBefore){p.insertBefore.parentNode.insertBefore(el,p.insertBefore);}else if(parent){parent.appendChild(el);}return el;},
		el : function(id){return typeof(id)==='string'?document.getElementById(id):id;},
		bind : function(f,context){var proxy=function(){var c=arguments.callee;return c._prxyf.apply(c._prxyc || this,arguments);};proxy._prxyf=f;proxy._prxyc=context;proxy.unbind=lib.bind.unbind;f=context=null;return proxy;},
		//bind : function(f,context){return function(){return f.apply(context || this,arguments);};},
		handle : function(el,type,f){type=(type+'').replace(/^on/,'');if(el.addEventListener){el.addEventListener(type,f,false);}else{f.bind(el);el.attachEvent(type,f);}},
		unhandle : function(el,type,f){type=(type+'').replace(/^on/,'');if(el.removeEventListener){el.removeEventListener(type,f,false);}else{if(f._prxyf){f.unbind();f=f._prxyf;}el.detachEvent(type,f);}},
		hide : function(el){if(typeof(el)==='string'){el=lib.el(el);}el.style.display='none';},
		show : function(el){if(typeof(el)==='string'){el=lib.el(el);}el.style.display='';},
		attrs : function(node,obj){ for(var i in obj){if(obj.hasOwnProperty(i)){ node.setAttribute(i, obj[i]); }} },
		mapReduce : function(what,cb,start){var i;start=start||{};if(lib.isArray(what)){for(i=0;i<what.length;i++){cb.call(start,what[i],i,start);}}else{for(i in what){if(what.hasOwnProperty(i)){cb.call(start,what[i],i,start);}}}return start;},
		each : function(what,cb){return lib.mapReduce(what,cb);},
		extend : function(base,ext){lib.each(ext,function(p,i){base[i]=p;});return base;},
		json : window.JSON || (function(){eval("function s(t){return t.replace(/(['\"/\\\\])/gim,'\\\\$1');}function a(v){switch(lib.isArray(v)?'array':typeof(v)) {case 'number':return v+'';case 'string':return '\"'+s(v).replace(/\r?\n/gim,'\\n')+'\"';case 'date':return '\"'+Math.floor(v.getTime()/1000)+'\"';case 'boolean':return v?'true':'false';case 'array':var t=[];for(var i=0; i<v.length; i++){t[i]=strval(v[i]);}return '['+t.join(',')+']';case 'object':return b(v);default:return 'null';}}function b(o){var t=[],c=0,n;for(n in o){if(o.hasOwnProperty(n)){t[c++]='\"'+s(n)+'\":'+a(o[n]);}}return '{'+t.join(',')+'}';}return {stringify:function(obj){return b(obj);},parse:function(str){return eval('(' + str + ')');}}");})(),
		qs : {
			parse : function(s){var p={},c=s.split('&');lib.each(c,function(v,i){i=v.indexOf('=');p[decodeURIComponent(v.substring(0,i))]=decodeURIComponent(v.substring(i+1));});return p;},
			stringify : function(p){var s='';lib.each(p,function(v,k){s+='&'+encodeURIComponent(k)+'='+encodeURIComponent(v);});return s.replace('&','');}
		},
		xml : {
			parse : function(xml){var x;if(window.DOMParser){x=new window.DOMParser().parseFromString(xml,'text/xml');}else{x=new window.ActiveXObject('Microsoft.XMLDOM');x.async='false';x.loadXML(xml);}return x;}
		},
		globalize : function(){lib.extend(window,lib);}
	};
	lib.bind.unbind = function(){this._prxyc=null;};
	
	lib.jsonp.net=function(url,callback,opt){lib.jsonp('http://jsonp.net/'+lib.json.stringify(lib.extend({url:url,callback:"{callback}"}, opt || {})), callback);};
	this.jsonp={net:lib.jsonp.net};
	
	this.picolib=lib;
}());
</script>
</head>
<body>
<input id="url" type="url" />
<iframe id="rend"></iframe>
<div id="console">
    <div id="console_output"></div>
</div>
<div id="insp"></div>
<span id="throbber">Collapsing JSON document tree...</span>
<span id="conv"></span>
<script>
// Two areas to show two representations:
var rend = picolib.el('rend'),
    insp = picolib.el('insp'),
    throbber = picolib.el('throbber'),
    urlBar = picolib.el('url'),
    conv = picolib.el('conv'),
    consoleOutput = picolib.el('console_output'),
    currentUrl;



var console = {
    warn : function(){this.log.apply(this, ['Warning: '].concat(Array.prototype.slice.call(arguments,0)));},
    error : function(){this.log.apply(this, ['Error: '].concat(Array.prototype.slice.call(arguments,0)));},
    log : function(args){
        picolib.create({
            type : 'div',
            props : {
                className : 'console_log',
                innerHTML : Array.prototype.join.call(arguments,' ').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
            }
        }, consoleOutput);
    }
};


setTimeout(function() {
    setup();
    fetch(location.href.split('#')[1] || "http://pastebin.com/raw.php?i=8MrNr1zn");
    //fetch("http://jasonmillerdesign.com/");
}, 50);

function setup() {
    picolib.handle(urlBar, 'keydown', function(e) {
        if ((e.keyCode || e.which)===13) {
            fetch(this.value);
            return false;
        }
    });
}


function resetFrame(frame) {
    var doc = frame.contentWindow.document;
    doc.open();
    doc.write('');
    doc.close();
    
    picolib.handle(doc, 'click', function(e) {
        var el, href;
        e = e || this.event;
        el = e.target || e.srcElement;
        do {
            if (el.nodeName && (el.nodeName+'').toLowerCase()==='a') {
                href = el.getAttribute('href');
                conv.innerHTML = href;
                href = conv.textContent || conv.innerText || conv.nodeValue;
                if (href) {
                    if (href.substring(0,11).toLowerCase()==='javascript:') {
                        console.log('evaluating javascript from "javascript:" link :: ', href.substring(11));
                    }
                    else {
                        fetch(resolveLink(href, currentUrl));
                    }
                    break;
                }
            }
        } while((el=el.parentNode) && el!==this.body);
        if (e.preventDefault) {
            e.preventDefault();
        }
        return e.returnValue=false;
    });
}

 
function resolveLink(url, pageUrl) {
    var baseReg = /^[^:]+:\/\/[^\/]+/gim,
        base;
    baseReg.lastIndex = 0;
    base = baseReg.exec(pageUrl)[0];
    if (url.indexOf('://')>-1) {
        return url;
    }
    if (url.substring(0,2)==='./') {
        url = url.substring(2);
    }
    if (url[0]==='/') {
        return base+url;
    }
    return pageUrl.replace(/\/[^\/]+$/gim,'\/') + url;
}


function fetch(url) {
    var time = new Date().getTime();
    
    consoleOutput.innerHTML = '';
    
    // Download some HTML:
    jsonp.net(url, function(res) {
        var body=res.body, dom;
        console.log('Fetch: ', Math.round(new Date().getTime()-time)+'ms');
        
        location.href = '#' + (res.url || url);
        
        urlBar.value = currentUrl = url;
        
        // Parse the HTML:
        time = new Date().getTime();
        dom = HTMLParser.parse(res.body);
        console.log('Parse: ', Math.round(new Date().getTime()-time)+'ms');
        
        // Look at your console:
        //console.log('Parsed DOM: ', dom);
        
        // Set some rendering options:
        var opt = {
            // render in a different document:
            document : rend.contentWindow.document,
            
            // Only render these HTML elements:
            whitelist : 'a b i em strong span p ul ol li dd dt table tbody thead tfoot tr td th img div input textarea button form fieldset label pre code section caption head foot html xml body head link style meta title iframe'.split(' ')
        };
        
        resetFrame(rend);
        
        time = new Date().getTime();
        HTMLRenderer.render(
            dom.childNodes[0].childNodes,
            opt.document.body,
            opt
        );
        /*
        // Render <head> into <head>:
        HTMLRenderer.render(
            dom.childNodes[0].childNodes[0].childNodes,
            opt.document.getElementsByTagName('head')[0],
            opt
        );
        
        // Render <body> into <body>:
        HTMLRenderer.render(
            dom.childNodes[0].childNodes[1].childNodes,
            opt.document.body,
            opt
        );
        */
        console.log('Render: ', Math.round(new Date().getTime()-time)+'ms');
        
        // Show a JSON representation of the parsed DOM:
        /*
        picolib.show(throbber);
        insp.innerHTML = prettySource(dom);
        
        /// ...Collapse the nesting:
        picolib.hide(insp);
        if (window._killCollapser) {
            window._killCollapser();
        }
        (function() {
            var spans = insp.getElementsByTagName('span'),
                timer,
                i = spans.length,
                next = function() {
                    var c = 100;
                    do {
                        spans[--i].onclick && spans[i].onclick();
                    } while(i>0 && --c>0)
                    (i>0 ? (timer=setTimeout(next, 10)) : done());
                },
                done = window._killCollapser = function() {
                    picolib.hide(throbber);
                    clearTimeout(timer);
                    window._killCollapser = done = next = spans = timer = i = null;
                };
            next();
        }());
        picolib.show(insp);
        */
        
        /*
        picolib.hide(insp);
        var spans = insp.getElementsByTagName('span');
        for (i=spans.length; i--; ) {
            if (spans[i].getAttribute('onclick')) {
                spans[i].onclick();
            }
        }
        picolib.show(insp);
        */
        
        // Done!
    });
}








/** Render a DOM object using an existing DOM.
 *  @class
 */
var HTMLRenderer = {
    /** @lends HTMLRenderer */
    
    /** Render a DOM Node or document into a node.
     *  @param n      A Node or Document
     *  @param into   A node to append the constructed elements to
     *  @returns {HTMLElement}
     */
    render : function node(n, into, options) {
        var i, d;
        options = options || {};
        //console.log('node(',n,',',into,')');
        if (!n) { return false; }
        if (Object.prototype.toString.call(n)==='[object Array]') {
            for (i=0; i<n.length; i++) {
                node(n[i], into, options);
            }
        }
        else if (n.nodeName==='#document') {
            node(n.childNodes, into, options);
        }
        else {
            if (n.nodeType===3) {
                d = document.createTextNode(n.textContent);
            }
            else if (n.nodeType===4) {
                d = document.createComment(' <![CDATA['+n.textContent+']]> ');
            }
            else if (n.nodeType===8) {
                d = document.createComment(n.textContent);
            }
            else {
                if (options.blacklist && options.blacklist.indexOf(n.nodeName)>-1) {
                    return false;
                }
                if (options.whitelist && options.whitelist.indexOf(n.nodeName)===-1) {
                    return false;
                }
                d = (options.document || document).createElement(n.nodeName);
                for (i in n.attributes) {
                    if (n.attributes.hasOwnProperty(i)) {
                        d.setAttribute(i, n.attributes[i]);
                    }
                }
                if (n.childNodes && n.childNodes.length>0) {
                    node(n.childNodes, d, options);
                }
                else {
                    d.innerHTML = n.innerHTML;
                }
            }
            into.appendChild(d);
        }
        return d;
    }
};








/** HTML DOM parser.
 *  @class
 */
var HTMLParser = (function() {
        /** @exports exports as HTMLParser# */
    var exports = {},
        util = {},
        splitAttrsTokenizer = /([a-z0-9_\:\-]*)\s*?=\s*?(['"]?)(.*?)\2\s+/gim,
        domParserTokenizer = /(?:<(\/?)([a-zA-Z][a-zA-Z0-9\:]*)(?:\s([^>]*?))?((?:\s*\/)?)>|(<\!\-\-)([\s\S]*?)(\-\->)|(<\!\[CDATA\[)([\s\S]*?)(\]\]>))/gm, // [^]
        splitAttrs;
    
    util.extend = function(a, b) {
        for (var x in b) {
            if (b.hasOwnProperty(x)) {
                a[x] = b[x];
            }
        }
        return a;
    };
    
    util.inherit = function(a, b) {
        var p = a.prototype;
        function F(){}
        F.prototype = b.prototype;
        a.prototype = new F();
        util.extend(a.prototype, p);
        a.prototype.constructor = a;
    };
    
    util.selfClosingTags = {img:1,br:1,hr:1,meta:1,link:1,base:1,input:1};
    
    util.getElementsByTagName = function(el, tag) {
        var els=[], c=0, i, n, j;
        if (!tag) {
            tag = '*';
        }
        tag = tag.toLowerCase();
        if (el.childNodes) {
            for (i=0; i<el.childNodes.length; i++) {
                n = el.childNodes[i];
                if (n.nodeType===1 && (tag==='*' || n.nodeName===tag)) {
                    els[c++] = n;
                }
                Array.prototype.splice.apply(els, [els.length, 0].concat(util.getElementsByTagName(n, tag)));
                c = els.length;
            }
        }
        return els;
    };
    
    util.splitAttrs = function(str) {
        var obj={}, token;
        if (str) {
            splitAttrsTokenizer.lastIndex = 0;
            str = ' '+(str || '')+' ';
            while (token=splitAttrsTokenizer.exec(str)) {
                obj[token[1]] = util.decodeEntities(token[3]);
            }
        }
        return obj;
    };
    
    util.ta = document.createElement('textarea');
    util.encodeEntities = function(str) {
        util.ta.value = str || '';
        return util.ta.innerHTML;
    };
    util.decodeEntities = function(str) {
        util.ta.innerHTML = str || '';
        return util.ta.value;
    };
    
    util.htmlToText = function(html) {
        html = html.replace(/<\/?[a-z].*?>/gim, '');
        return util.decodeEntities(html);
    };
    
    function HTMLElement() {
        this.childNodes = [];
    };
    util.extend(HTMLElement.prototype, {
        nodeType : 1,
        textContent : '',
        getElementsByTagName : function(tag) {
            return util.getElementsByTagName(this, tag);
        },
        getAttribute : function(a) {
            if (this.attributes.hasOwnProperty(a)) {
                return this.attributes[a];
            }
        },
        setAttribute : function(name, value) {
            var lcName = (name+'').toLowerCase();
            this.attributes[name] = value + '';
            if (lcName==='id' || lcName==='name') {
                this[lcName] = value;
            }
            if (lcName==='class') {
                this.className = value;
            }
        },
        getElementById : function(id) {
            var all = this.getElementsByTagName('*'),
                i;
            for (i=all.length; i--; ) {
                if (all[i].id===id) {
                    return all[i];
                }
            }
        }
    });
    exports.HTMLElement = HTMLElement;
    
    function Node(){}
    util.extend(Node.prototype, {
        toString : function(){ return this.textContent; }
    });
    
    function TextNode(){}
    util.inherit(TextNode, Node);
    util.extend(TextNode.prototype, {
        nodeType : 3,
        nodeName : '#text'
    });
    exports.TextNode = TextNode;
    
    function CommentNode(){}
    util.inherit(CommentNode, Node);
    util.extend(CommentNode.prototype, {
        nodeType : 8,
        nodeName : '#comment'
    });
    exports.CommentNode = CommentNode;
    
    function CDATASectionNode(){}
    util.inherit(CDATASectionNode, Node);
    util.extend(CDATASectionNode.prototype, {
        nodeType : 4,
        nodeName : '#cdata-section'
    });
    exports.CDATASectionNode = CDATASectionNode;
    
    
    util.blockConstructors = {
        '<!--'      : CommentNode,
        '<![CDATA[' : CDATASectionNode
    };
    
    
    /** Parse a string of HTML into an HTML DOM.
     *  @param {String} str        A string containing HTML
     *  @returns {Document}        A Node, the type corresponding to the type of the root HTML node.
     */
    exports.parse = function(str) {
        var tags, doc, parent, prev, content, token, text, i, 
            bStart, bText, bEnd, BlockConstructor, commitTextNode, tag;
        tags = [];
        domParserTokenizer.lastIndex = 0;
        
        parent = doc = util.extend(new HTMLElement(), {
            nodeType : 9,
            nodeName : '#document'
        });
        
        commitTextNode = function() {
            // note: this is moved out of the loop but still uses its scope!!
            if (parent && tags.length>0) {
                prev = tags[tags.length-1];
                i = (prev.documentPosition.closeTag || prev.documentPosition.openTag).end;
                if (prev.parentNode===parent && i && i<tag.documentPosition.openTag.start) {
                    text = str.substring(i, tag.documentPosition.openTag.start);
                    if (text) {
                        text = util.decodeEntities(text);
                        parent.childNodes.push(util.extend(new TextNode(), {
                            textContent : text,
                            nodeValue : text,
                            parentNode : parent
                        }));
                    }
                }
            }
        };
        
        while (token=domParserTokenizer.exec(str)) {
            //console.log(token);
            bStart = token[5] || token[8];
            bText = token[6] || token[9];
            bEnd = token[7] || token[10];
            if (bStart==='<!--' || bStart==='<![CDATA[') {
                i = domParserTokenizer.lastIndex - token[0].length;
                BlockConstructor = util.blockConstructors[bStart];
                if (BlockConstructor) {
                    tag = util.extend(new BlockConstructor(), {
                        textContent : bText,
                        nodeValue : bText,
                        parentNode : parent,
                        documentPosition : {
                            openTag : {
                                start : i,
                                end : i+bStart.length
                            },
                            closeTag : {
                                start : domParserTokenizer.lastIndex - bEnd.length,
                                end : domParserTokenizer.lastIndex
                            }
                        }
                    });
                    commitTextNode();
                    tags.push(tag);
                    tag.parentNode.childNodes.push(tag);
                }
            }
            else if (token[1]!=='/') {
                tag = util.extend(new HTMLElement(), {
                    nodeName : (token[2]+'').toLowerCase(),
                    attributes : util.splitAttrs(token[3]),
                    parentNode : parent,
                    documentPosition : {
                        openTag : {
                            start : domParserTokenizer.lastIndex - token[0].length,
                            end : domParserTokenizer.lastIndex
                        }
                    }
                });
                tag.className = tag.attributes['class'];
                tag.id = tag.attributes['id'];
                tag.name = tag.attributes['name'];
                commitTextNode();
                tags.push(tag);
                tag.parentNode.childNodes.push(tag);
                if ((token[4] && token[4].indexOf('/')>-1) || util.selfClosingTags.hasOwnProperty(tag.nodeName)) {
                    tag.documentPosition.closeTag = tag.documentPosition.openTag;
                    tag.isSelfClosingTag = true;
                    tag.innerHTML = '';
                    tag.outerHTML = str.substring(tag.documentPosition.openTag.start, tag.documentPosition.closeTag.end);
                }
                else {
                    parent = tag;
                }
            }
            else {
                // Close parent node if end-tag matches
                if ((token[2]+'').toLowerCase()===parent.nodeName) {
                    tag = parent;
                    parent = tag.parentNode;
                    //parent = parent.parentNode;
                    //tag = tags.pop();
                    delete tag.isSelfClosingTag;
                    tag.documentPosition.closeTag = {
                        start : domParserTokenizer.lastIndex - token[0].length,
                        end : domParserTokenizer.lastIndex
                    };
                    tag.innerHTML = str.substring(tag.documentPosition.openTag.end, tag.documentPosition.closeTag.start);
                    tag.outerHTML = str.substring(tag.documentPosition.openTag.start, tag.documentPosition.closeTag.end);
                    tag.textContent = util.htmlToText(tag.innerHTML);
                }
                // account for abuse of self-closing tags when an end-tag is also provided:
                else if ((token[2]+'').toLowerCase()===tags[tags.length-1].nodeName && tags[tags.length-1].isSelfClosingTag===true) {
                    tag = tags[tags.length-1];
                    console.warn('HTML Error: discarding dangling <\/'+token[2]+'> tag. Already closed via: '+tag.outerHTML);
                    delete tag.isSelfClosing;
                    tag.documentPosition.closeTag = {
                        start : domParserTokenizer.lastIndex - token[0].length,
                        end : domParserTokenizer.lastIndex
                    };
                }
                else {
                    console.warn('tag mismatch: "'+token[2]+'" vs "'+tag.nodeName+'"', tag);
                }
            }
        }
        
        /*
        for (i=doc.childNodes.length; i--; ) {
            if (doc.childNodes[i].nodeName==='html') {
                doc = doc.childNodes[i];
                break;
            }
        }
        */
        
        doc.documentElement = doc.getElementsByTagName('html')[0];
        doc.body = doc.getElementsByTagName('body')[0];
        
        return doc;
    };
    
    return exports;
}());













/** Generate a colorized, indented, collapsible representation of an object's structure.<br />
 *  Recursive and self-referential structures are fully supported.
 *  @param {Any} obj      Any object.
 *  @returns {String} html
 */
function prettySource(obj) {
    var maxDepth = -1,
        depth = 0,
        root = true,
        sp = "    ",
        hits = [],
        hitCount = 0,
        dig,
        expander;
    
    expander = 'var s=this,i,o,c=0;while((s=s.nextSibling) && (++c)<3){if(s.nodeType===1 && s.getAttribute("i")==="i"){i=s;break;}}if(i){s=i.getAttribute("c");o=i.innerText || i.textContent || i.nodeValue;if(s){i.innerHTML=s;s="";}else if(o.length>20){s=i.innerHTML;i.innerHTML=o[0]+" ... "+o[o.length-1];}i.setAttribute("c",s);return false;}';
    // s.display=(s.display==="none"?"inline":"none");
    
    function objProp (prop) {
        var t = (typeof(prop)+"").toLowerCase();
        if (prop===null) {
            return "<span style='color:#A6BE88; font-style:italic;'>null</span>,\n";
        }
        else if (prop===undefined) {
            return "<span style='color:#BBB; font-style:italic;'>undefined</span>,\n";
        }
        else if (t==="function") {
            return "<span style='color:#0A0;'>" + (prop+"").replace("<","&lt;").replace(">","&gt;").replace(/function\s?\(/,"function <strong>"+((prop.constructor&&prop.constructor.name)||prop.name||"")+"</strong>(").replace(/\n/gim,'\n    ') + "</span>,\n";
        }
        else if (t==="string") {
            return "<span i='i' style='color:#D0D;'>\"" + prop.replace(/</gim,'&lt;').replace(/>/gim,'&gt;') + "\"</span>,\n";
        }
        else if (t==="number") {
            return "<span style='color:#F00;'>" + prop + "</span>,\n";
        }
        else if (t==="boolean") {
            return "<span style='color:#00D;'>" + (prop===true?"true":"false") + "</span>,\n";
        }
        else if (typeof(prop)==='object' || Object.prototype.toString.apply(prop)==="[object Array]") {
            return branch(prop).replace(/\n/gim,'\n'+sp) + ",\n";
        }
        return (prop.toSource || prop.toString)().replace(/^\((new\s)?(.+)\)$/,'$2') + ",\n";
    }
    function branch (what) {
        var wasRoot=root===true, x, dig, text="", m=0, i;
        root = false;
        for (i=hits.length; i--; ) {
            if (hits[i]===what) {
                return "<span style='color:#BBB; font-style:italic;'>[Recursion]</span>";
                break;
            }
        }
        hits[hitCount++] = what;
        if (maxDepth>0 && depth>maxDepth) {
            return "<span style='color:#BBB; font-style:italic;'>[Maximum Depth Reached]</span>";
        }
        depth++;
        if (Object.prototype.toString.apply(what)==="[object Array]") {
            text = "<pre i='i' style='color:#555; display:"+(wasRoot===false?"inline":"block")+"; margin:0; padding:0;'><strong>[</strong><span>\n";
            for (x=0; x<what.length; x++) {
                dig = (x+"# ").length;
                text += sp.substring(0,4-dig) + "<span style='color:#ABC; font-style:italic;'>#" + x + "</span> " + objProp(what[x]);
            }
            return text.replace(/\,\n$/,'\n') + "</span><strong>]</strong></pre>";
        }
        //else if (Object.prototype.toString.apply(what)==="[object Object]") {
        else if (typeof(what)==="object") {
            text = "<pre i='i' style='color:#555; display:"+(wasRoot===false?"inline":"block")+"; margin:0; padding:0;'><strong>{</strong>\n";
            for (x in what) {
                if (what.hasOwnProperty(x)) {
                    m = Math.max(m,(x+"").length);
                }
            }
            m += 1;
            for (x in what) {
                try {
                    if (what.hasOwnProperty(x)) {
                        text += sp + '<span onclick="'+expander.replace(/"/gm,'&quot;')+'" style="cursor:pointer; color:#089;">' + x + "</span>"+(new Array(m-(x+"").length).join(" "))+" : " + objProp(what[x]);
                    }
                }catch(err){
                    text += sp + "<span style='color:#089;'>" + x + "</span>"+(new Array(m-(x+"").length).join(" "))+" : <i>[access restriction]</i>";
                }
            }
            return text.replace(/\,\n$/,'\n') + "<strong>}</strong></pre>";
        }
    }
    var r = branch(obj);
    sp = root = branch = objProp = null;
    return r;
}
</script>
</body>
</html>